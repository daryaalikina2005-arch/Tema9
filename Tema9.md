# Тема 9. ООП на Python: концепции, принципы и примеры реализации
Отчет по Теме №9 выполнила:
- Аликина Дарья Андреевна
- АИС-23-1

| Задание    | Лаб_раб | Сам_раб |
|------------|---------|---------|
| Задание 1  | +       | +       |
| Задание 2  | +       | +       |
| Задание 3  | +       | +       |
| Задание 4  | +       | +       |
| Задание 5  | +       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;


## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/1.png)

### Выводы

При помощи `__slots__ = ['name']` устанавливаем параметры класса

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print("Обычное мороженое")

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/2.png)

### Выводы

При помощи`if isinstance(ingredient, str)` проверяем, что переменная относится к стринг

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        if hasattr(self, '_value'):
            return self._value
        else:
            return "value удалено"

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/3.png)

### Выводы

Создали для класса геттер и сеттер, а также функцию удаления значения. Выводилась ошибки потому что пользователь пытался выводить удаленное значение
  
## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Dog is {cat.className}, but they say {cat.sounds}")
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/4.png)

### Выводы

Создали класс млекопитающие и два его наследника - кошку и собаку

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/5.png)

### Выводы
В данном коде используются статические методы, а так же обычный полиморфизм

## Задания для самостоятельного выполнения: Задание Садовник и помидоры.
### 
### Классовая структура:
### Есть Помидор со следующими характеристиками:
### • Индекс
### • Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) Помидор может:
### • Расти (переходить на следующую стадию созревания)
### • Предоставлять информацию о своей зрелости
### Есть Куст с помидорами, который:
### • Содержит список томатов, которые на нем растут
### А также может:
### • Расти вместе с томатами
### Предоставлять информацию о зрелости всех томатов
### • Предоставлять урожай
### И также есть Садовник, который имеет:
### • Имя
### • Растение, за которым он ухаживает
### Он может:
### • Ухаживать за растением
### • Собирать с него урожай
### Задание:
### Класс Tomato:
### 1) Создайте класс Tomato
### 2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
### 3) Создайте метод \_\_init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
### 4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания
### 5) Создайте метод is_ripe(), который будет проверять, что томат созрел
### Класс TomatoBush:
### 1) Создайте класс TomatoBush
### 2) Определите метод \_\_init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes 3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
### 4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми. 
### 5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
### Класс Gardener:
### 1) Создайте класс Gardener
### 2) Создайте метод \_\_init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
### 3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
### 4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
### 5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству
### Тесты:
### 1) Вызовите справку по садоводству
### 2) Создайте объекты классов TomatoBush и Gardener 3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
### 4) Попробуйте собрать урожай, когда томаты еще не дозрели.
### Продолжайте ухаживать за ними
### 5) Соберите урожай
### Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.

```python
class Tomato:
    # 2) Статическое свойство states, содержащее все стадии созревания помидора
    states = {
        0: 'отсутствует',
        1: 'цветение',
        2: 'зеленый',
        3: 'красный'
    }

    # 3) Метод __init__
    def __init__(self, index):
        """
        _index - защищенное свойство (protected), передается параметром
        _state - защищенное свойство (protected), принимает первое значение из словаря states
        """
        self._index = index  # Индекс помидора
        self._state = 0  # Начальная стадия созревания

    # 4) Метод grow(), который переводит томат на следующую стадию созревания
    def grow(self):
        if self._state < 3:  # Если томат еще не красный
            self._state += 1  # Переходим на следующую стадию
        print(f'Помидор {self._index} теперь на стадии: {Tomato.states[self._state]}')

    # 5) Метод is_ripe(), который проверяет, что томат созрел
    def is_ripe(self):
        return self._state == 3  # Томат созрел, если он красный


class TomatoBush:
    # 2) Метод __init__, который принимает количество томатов
    def __init__(self, num_tomatoes):
        """
        tomatoes - динамическое свойство, содержащее список объектов класса Tomato
        """
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]  # Создаем список томатов

    # 3) Метод grow_all(), который переводит все томаты на следующий этап созревания
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()  # Каждый томат растет

    # 4) Метод all_are_ripe(), который возвращает True, если все томаты созрели
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)  # Проверяем все томаты

    # 5) Метод give_away_all(), который чистит список томатов после сбора урожая
    def give_away_all(self):
        self.tomatoes = []  # Очищаем список томатов


class Gardener:
    # 2) Метод __init__
    def __init__(self, name, plant):
        """
        name - публичное свойство, передается параметром
        _plant - защищенное свойство (protected), принимает объект класса TomatoBush
        """
        self.name = name  # Имя садовника
        self._plant = plant  # Растение, за которым ухаживает садовник

    # 3) Метод work(), который заставляет садовника работать
    def work(self):
        print(f'{self.name} работает над растением...')
        self._plant.grow_all()  # Растение растет под уходом садовника

    # 4) Метод harvest(), который проверяет и собирает урожай
    def harvest(self):
        print(f'{self.name} проверяет, готов ли урожай...')
        if self._plant.all_are_ripe():  # Если все томаты созрели
            print('Урожай собран!')
            self._plant.give_away_all()  # Собираем урожай
            return True
        else:
            print('Еще не все помидоры созрели! Нужно продолжать ухаживать.')
            return False

    # 5) Статический метод knowledge_base(), выводящий справку по садоводству
    @staticmethod
    def knowledge_base():
        print("""
     СПРАВКА ПО САДОВОДСТВУ:
    Стадии созревания помидора:
    1. Отсутствует
    2. Цветение  
    3. Зеленый
    4. Красный (созрел)

    Садовник должен ухаживать за растением до тех пор,
    пока все помидоры не станут красными.
    Только тогда можно собирать урожай.
        """)


# ТЕСТИРОВАНИЕ ПРОГРАММЫ

if __name__ == "__main__":
    # 1) Вызываем справку по садоводству
    print("ТЕСТ 1: Вызов справки по садоводству")
    Gardener.knowledge_base()

    # 2) Создаем объекты классов TomatoBush и Gardener
    print("ТЕСТ 2: Создание объектов")
    bush = TomatoBush(3)  # Куст с 3 помидорами
    gardener = Gardener("Валентин", bush)  # Садовник Валентин
    print(f'Создан садовник: {gardener.name}')
    print(f'Создан куст с {len(bush.tomatoes)} помидорами')

    # 3) Используя объект класса Gardener, ухаживаем за кустом с помидорами
    print("\nТЕСТ 3: Уход за растениями")
    gardener.work()  # Первый уход

    # 4) Пробуем собрать урожай, когда томаты еще не дозрели
    print("\nТЕСТ 4: Попытка собрать урожай раньше времени")
    gardener.harvest()  # Пытаемся собрать урожай

    # Продолжаем ухаживать за ними
    print("\nТЕСТ 5: Продолжаем ухаживать")
    for i in range(2):  # Ухаживаем еще 2 раза
        print(f"\nУход №{i + 2}:")
        gardener.work()

    # 5) Собираем урожай
    print("\nТЕСТ 6: Сбор урожая")
    success = gardener.harvest()
    if success:
        print(f'Урожай успешно собран! На кусте осталось {len(bush.tomatoes)} помидоров.')
    else:
        print('Нужно еще подождать...')

    # Дополнительная проверка
    print("ПРОВЕРКА: Попытка ухаживать после сбора урожая")
    gardener.work()  # Пытаемся ухаживать после сбора урожая
    print(f'На кусте осталось помидоров: {len(bush.tomatoes)}')
```
### Результат.

![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/11.png)
![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/12.png)
![Меню](https://github.com/daryaalikina2005-arch/Tema9/blob/master/9/13.png)

### Выводы

Была созданна программа, которая моделирует процесс выращивания помидоров садовником, где помидоры проходят 4 стадии созревания, и урожай можно собрать только когда все помидоры станут красными. Так же коду были данны подробные комментарии к каждому шагу

## Общие выводы по теме
Я усвоила тему концепций, принципов и пример реализаций на Python. Так же практика в Python помогла закрепить изученный материал 
